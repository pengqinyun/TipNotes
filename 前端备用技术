Onpage anchor
href="#foo"会自动导航到id="foo"的tag


Position

static是默认的flow，relative是保存原有的坑，接受相对于原有的坑的新位置

absolute的父元素一定要是relative，是相较于父元素的relative，处于一个absolute position,实际上absolute会把所有非static的父系元素认为父系
基本上relative唯一的用法就是做absolute等position的父元素，因为本身去位移relative会遮挡别的static flow, which is very confusing

当元素处于absolute时，该元素被移出static flow并失去本属于它的static空间，这点和relative不同
举例，父元素下第一个子元素是img，第二个是div，让div中文字固定的悬浮在img上，就可以用absolute
应用场景举例，某个img a:hover可以把position改成relative然后top：-4px，如此鼠标hover时图片会向上移动一点点

fixed不管怎么scroll都固定处于整个页面的某固定位置,fixed没有父亲！
每一个默认static元素都有默认z-index=0

sticky是一个相对scroll存在的概念，譬如说某元素是sticky并top:140px，那一开始该元素处于正常flow中，但一旦scroll下来到140px时，该元素就变成fixed了
需要注意的是，sticky的fixed形态只在父系元素里有用，换言之when sticky element hit the bottom of its parent element, it stops been fixed
所以譬如一个目录，A,B,C...是不同的sticky tag，如果A,B,C的父系之间相互平行，那A碰到B后就会消失，B变sticky，碰到C后消失.....
最后注意sticky要prefix，即-webkit-sticky;-moz-sticky;-ms-sticky;-o-sticky



Pseudo Class
:focus正在输入时
:first-child
:nth-child(even)


Animation
transform: translate(X, Y) / scale(X,Y) / rotate()
transition: background 1s, transform 1s 1s ease-in    # 可以按顺序调节动画，第一个parameter是duration,第二个是delay,第三个是timing function

@keyframes foo {
  from{ transform: translateX(0) }
  to{ transform: translateX(200px) }
}
# 某张图片{
  .......
  animation-name: foo;
  animation-duration: 3s;
  animation-fill-mode: forwards;         # 意思是到点之后停那不动，否则default是重新回原点backwards
  animation-delay: 2s;
  animation-iteration-count: infinite;
  animation-direction: reverse/normal/alternate;
  animation-timing-function: linear;    # default是ease
}
@keyframes jump {
  0%{ top:-40px }
  50%{ top:0px }
  100%{ top:-40px }
}
某张图片{
  .......
  aniamtion: drive 3s both infinite linear,
             jump 0.3s 1.2s ease;
}


Grid基础
# 父系 {
  display: grid;
  grid-template-columns: 20% 30% 50%;  # or  grid-template-columns: 1fr 2fr 1fr;  or columns比较多时： grid-template-columns:repeat(9,1fr);
  grid-template-rows: 200px 200px 300px 500px;      # 规定了每一row的高度   or    grid-template-rows:repeat(3,200px);   也可以套minmax
  grid-auto-rows: 200px;               # 固定每一格高度为200px  or grid-auto-rows: minmax(200px,auto);
  grid-column-gap: 10px;               # 左右无gap，每一column中间的gap
  grip-row-gap: 10px;                  # 或者直接设 grid-gap: 10px;
  max-width: 960px;
  margin: 0 auto;
}

Grid中阶
# 父系 {
  grid-template-columns: repeat(6, 1fr);
  grid-template-rows: repeat(4, minmax(150px, auto));
  grid-gap: 10px;
  align-items: strech/start/end;
  justify-items: start/end;
}
# 父系 one {
  grid-coloumn-start: 1;
  grid-coloumn-end: 3;               # 或者可以统一 grid-column: 1/3;   记住1是起始位置，即原点坐标是1，1，所以1/3其实只占了两column
  grid-row: 2/4;
  justify-self: start;
  align-self: end;
}
小trick，在父系里面建一个id为grid的div，然后在div里面放12个<p></p>
# 父系 {
  position: relative;
}
# grid {
  display: grid;
  position: absolute;
  top: 0;
  left: 0;
  grid-template-columns: repeat(12,1fr);
  grid-auto-rows: minmax(100%,auto);
  width: 100%;
  height: 100%;
  background: transparent;
  padding: 0;
  display: none;
}
# grid p {
  border: 1px solid;
  background: #000;
  margin: 0;
  opacity: 0.2;
}
然后通过一个checkbox来勾选显示与否，首先在父系外设一个<input type="checkbox">
input:checked + #父系#grid {
  display: grid;
}


Grid高阶
header{                     #可以选取任意元素，grid-area名字也可以随便起
  grid-area:header;
}
# 父系 {
  "header header header header"
  "aside . main main"                         # . 代表空白空间
  "nav nav main main"
  "section section section section"
  "section section section section"
  "footer footer footer footer";
}

@media screen and (min-width: 760px){.....}


Flex Box:

-------把父系元素定义成 display：flex, 则父系内所有元素呈直线排列
-------每个子元素可以用 flex:3 来调节, CSS会自动按比例在每一个父元素里分配
------- order:2 还可以assign不同的顺序
------- align-items: flex-start/-end/center 可竖直调节在父元素中的位置
------- flex-direction:column 可让子元素数值排列
------- width:20% 这个和CSS一样，按父系切20%给它,按照convention来说应该用flex-basis
------- justify-content: flex-start/-end/center/space-between(no margin on the side)/space-around
