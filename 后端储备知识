filter返还的是一个queryset，因为可能有好几个符合条件的对象，如果要精确定位某一个对象，用get_object_or_404

pandas本是一个处理大数据的插件，有各种matrices方法可以调用，但素！因为django自带的Json解码在应对中文编码时简直是一坨屎，所以本座还是捏着鼻子用了pandas，
至于xlrd还不错，可以直接用.原始录入的院校，省市信息，本座都存到了“冲天流程”这个文件夹中

搜索框相关:

F(stocks.price)指代旧的price，用于进行一些操作，譬如stocks.price=F(stocks.price)+2

Q()是指封装某个query，以便后续进行逻辑组合，譬如 Q(..) | ~Q(..),其中~表示not
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)), question__startswith='Who')， Q（）可以传递更具体的参数，但要注意放到最前

AsyncIO:
单线程编程只能运用CPU算力的10%左右，要释放应用更多算力，async是解决办法


Django channel的consumer中使用了如下代码：
-------------------------------------------------------------------------------
    try:
        PrivateConsumer.members[self.group_name].add(self.socket)      
    except:                                                             
        PrivateConsumer.members[self.group_name] = set([self.socket])   
---------------------------------------------------------------------------------
这个代码有意思在，它规避了所有的报错，来试着分析一下
members是该consumer class里自定义的literable dict，字典格式。如果该键位上（members[self.group_name]）为空的话，add方法失效，所以第一次新建走
except逻辑，在该键位上新建set([self.socket])，其中self.socket是一个user object，然而set()函数只接受iliterable variable，所以要把user object
list化，加上[]封装，变成一个user object的list representation
后续的add里面，会自动把object转化成list representation，所有不必操心这一点。当该group_name键位上不为空时，add方法生效，检验该键位是否有同样的value
如果有，则什么都不做，如果没有，则在该键位上加上新value
总体来说，这是一个很高效简洁的设计



* 关于M2M： 
  manyTomany relationship一定要非常重视！我几次database弄崩都是因为这个屌东西！
  Rule#1：使用through和第三方辅助模型完成M2M，以便日后拓展！(主要是日后可能在M2M关系中夹带字段)


                                             * * * * * * * * * * * * 
                                             * aggregate/annotate  *
                                             * * * * * * * * * * * * 
                                             
                      # 前置概念
                        join ===> 两张表，一张记录公司，譬如{id:1, company: google}，一张记录国籍，譬如{id:1, nation: america}
                        innerJoin 就是把两张表合并成一张，如果第一张表的某个公司的国籍，在第二张表里面没用相关记录，就不算入最终合成的表中，反之亦然
                        leftJoin 返还左表的全部行，如果右表没有国籍的相关记录，国籍是null             rightJoin反之
                        fullOuterJoin 返还两张表的所有行，缺失的为null
                                             
  * aggregate是对一个queryset取值，如avg，max等。 annotate是给一个queryset加上某一列attribute
  
  * Book.objects.all().aggregate(Avg('price')) ----> {'price__avg': 34.35}     
    all() is redundant所有可以拿掉，另外可以自定义返还key：   
    Book.objects.aggregate(average_price=Avg('price')) -------> {'average_price': 34.35}
    还可以返还多个key
    Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))  ----> {'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')}

  * 对于日期是反过来的，越古老的日期越小（时间戳嘛）
    Publisher.objects.aggregate(oldest_pubdate=Min('book__pubdate'))
    
    
 * q = Book.objects.annotate(Count('authors'))  ----> q[0].authors__count       返还 2
 
 * 与aggregate不同的是，annotate并不是一个执行语句，annotate返还的是一个queryset
   如果要annotate多个fields需要使用distinct：    q = Book.objects.annotate(Count('authors', distinct=True), Count('store', distinct=True))
   
 
 * 如果需要返还另一个model的某个字段，使用双下划：
   Store.objects.annotate(min_price=Min('books__price'), max_price=Max('books__price'))
   这行命令会返还所有store，每个store都会额外再有两个属性，分别为店内的最低价和最高价
   
 * Store.objects.aggregate(min_price=Min('books__price'), max_price=Max('books__price'))
   这行命令返还所有stores中的最低价和最高价

 * 双下划可以无限衍生，譬如说，找到所有store中所有书的所有作者中最年轻的作者的年龄
   Store.objects.aggregate(youngest_age=Min('books__authors__age'))
   
 * manyToMany关系也适用
   每个author所写的所有书的页数总和:  Author.objects.annotate(total_pages=Sum('book__pages'))
   所有author写的所有书的平均分:      Author.objects.aggregate(average_rating=Avg('book__rating'))
   
   
 * queryset本身也可以涵盖各种filter
   Book.objects.filter(name__startswith="Django").annotate(num_authors=Count('authors'))
   Book.objects.filter(name__startswith="Django").aggregate(Avg('price'))
   
 * 也可以有更烧脑的运作
   Book.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1)
   遇到这种情况，可以拆分成好几步来玩
   highly_rated = Count('book', filter=Q(book__rating__gte=7))
   Author.objects.annotate(num_books=Count('book'), highly_rated_books=highly_rated)
   
 * 玩这种复杂步骤时一定要注意执行顺序
 
 * order_by也蛮有用的
   Book.objects.annotate(num_authors=Count('authors')).order_by('num_authors')
   
 * 最后，可以对annotate的结果使用aggregation
   Book.objects.annotate(num_authors=Count('authors')).aggregate(Avg('num_authors'))
 
   

  
 
