filter返还的是一个queryset，因为可能有好几个符合条件的对象，如果要精确定位某一个对象，用get_object_or_404

pandas本是一个处理大数据的插件，有各种matrices方法可以调用，但素！因为django自带的Json解码在应对中文编码时简直是一坨屎，所以本座还是捏着鼻子用了pandas，
至于xlrd还不错，可以直接用.原始录入的院校，省市信息，本座都存到了“冲天流程”这个文件夹中



关于Serializer：

JsonResponse与HttpResponse不一样，默认是传递dictionary，但也可以传递别的data type，譬如list，return JsonResponse(data, safe=false)即可
serializer中，使用genericAPIviews通过URL参数自定义queryset时，竟然一定还非要带上modelviewset，是乃一奇案也，现下忙着上线无暇深挖，日后可以慢慢破

试看这个view：

    def snippet_list(request):
        if request.method == 'GET':
            snippets = Snippet.objects.all()
            serializer = SnippetSerializer(snippets, many=True)
            return JsonResponse(serializer.data, safe=False)

        elif request.method == 'POST':
            data = JSONParser().parse(request)
            serializer = SnippetSerializer(data=data)
            if serializer.is_valid():
                serializer.save()
                return JsonResponse(serializer.data, status=201)
            return JsonResponse(serializer.errors, status=400)

---------要么返还所有snippet，要么新建一个snippet(method==POST)嘛....与之对应的，通常来说，还需要有一个detail view，用以获取/修改/删除单个snippet

    def snippet_detail(request, pk):
        try:
            snippet = Snippet.objects.get(pk=pk)
        except Snippet.DoesNotExist:
            return HttpResponse(status=404)

        if request.method == 'GET':
            serializer = SnippetSerializer(snippet)
            return JsonResponse(serializer.data)

        elif request.method == 'PUT':
            data = JSONParser().parse(request)
            serializer = SnippetSerializer(snippet, data=data)
            if serializer.is_valid():
                serializer.save()
                return JsonResponse(serializer.data)
            return JsonResponse(serializer.errors, status=400)

        elif request.method == 'DELETE':
            snippet.delete()
            return HttpResponse(status=204)

---------------------------------------------所以后续遇到的hyperlinkedmodel问题，只因REST本身默认写好了_detail逻辑，所以缺失时会报错


RestFramework中的viewset已经全盘写好了list到detail的逻辑，以api主页为例
而且如果要在function里直接call serializer的话，一次只能serialize一个object，还得自己写for loop，还他妈有中文编码等问题...所以本座干脆在前端抓取了
为什么一次只能serialize一个object呢？因为serializer就是这样设计的，基本上可以把serializer类比form

再看看generic View的例子：

    class FooView(APIView):

        def get(self, request, *args, **kwargs):
            qs = Post.objects.all()
            serializer = PostSerializer(qs, many=true)
            return Response(serializer.data)
            *** 注意！！！
            *** serialize完是一个OrderedDict，是一个django格式，javascript不知道咋回事，所以还要
            *** json.dumps让它变成一个json格式，然后！（按道理来说继承APIView是不需要specify response type的，不过加上也不会怀孕）
            *** 在前端用{{ foo_list }}的时候，javascript并不会把它当成一个string来parse（也不知道它是json格式了）
            *** 所以就会有各种乱码/&(l|g|quo)t什么的，所以要想在前端直接开用，还要加上mark_safe
            *** 所以终极态是 mark_safe(json.dumps(serializer.data))           一个简单的问题确实被复杂化了

        def post(self, request, *args, **kwargs):
            serializer = PostSerializer(data=request.data)
            if serializer.is_valid()
                serializer.save()
                return Response(serializer.data)
            return JsonResponse(serializer.errors, status=400)
            

RestFramework自带有各种view(APIview,ListAPIView什么的)，这是因为restframework接受的request和返还的response和django的不一样(本身它就不是处理http）
而且使用API时有API自己的exceptions，通过继承views，我们也获得了相关的处理，还有相关性的加密和防盗，总之还是很必要的
不仅如此，继承各种view后，还不需要specify response type，也不需要specify前端传回的type，REST会根据前端，后台，自行转换

同时上例可以看出，当我们需要返还一个object list的时候，使用views也是言下应有之义，还需要注意的是，serialzier也可以处理update的问题，目前虽然不用，
后续是一个可能能用上的技术
            

Rest_framework要求每一个FooSerializer都有一个foo_detail的view，因为每个serializer不光处理serializing data，还处理POST,DELETE等逻辑，所以
ModelSerializer并非没有这个detail view，只是REST已默认写好罢了，下文的相关bug也来源于此

继承 HyperlinkedModelSerializer，会隐式添加一个 HyperlinkedRelatedField 字段 url，而所有的外键都会变成 HyperlinkedRelatedField 字段，所以需要
手动设置 view_name 值，解决办法是在setting里面加上'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning'
即，HyperlinkedModelSerializer在处理模型关系上使用的url来表示外键关系，那每个url一定对应某一个模型的instance，那也就是需要有该instance的detail页面
（方便跳转嘛），如果没有就会报错，所以这是要解决的问题。除了上面的手法外，还可以人为的设定外键的view_name，譬如
---------------------------------------------------------------------------------------------------------------------------------
    class ContactSerializer(serializers.HyperlinkedModelSerializer):
        class Meta:
            model = Contact
            fields = '__all__'
            extra_kwargs = {
                'url': {'view_name': 'api:contact-detail'},
                'user':{'view_name':'api:user-detail'}
            }
----------------------------------------------------------------------------------------------------------------------------------



modelForm中，要specify某些fields不是requied，有两种方法

    class My_Form(ModelForm):

        address = forms.CharField(required=False)

        class Meta:
            model = My_Class
            fields = ('first_name', 'last_name' , 'address')
第二种解决办法：
    class My_Form(forms.ModelForm):
        class Meta:
            model = My_Class
            fields = ('first_name', 'last_name' , 'address')

        def __init__(self, *args, **kwargs):
            super(My_Form, self).__init__(*args, **kwargs)
            self.fields['address'].required = False

        
Signals:
通过设立signals和@receiver(foo_signal)，在该signal触发时，可以自动运行某些code



搜索框相关:

F(stocks.price)指代旧的price，用于进行一些操作，譬如stocks.price=F(stocks.price)+2

Q()是指封装某个query，以便后续进行逻辑组合，譬如 Q(..) | ~Q(..),其中~表示not
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)), question__startswith='Who')， Q（）可以传递更具体的参数，但要注意放到最前



Generic View:

是一个Django自带的一系列默认设定的view，可以customize

ListView会找寻一个default的app/modelname_list.html，除非specify template_name
get_queryset()自定义queryset
get_context_data(**kwargs)可以自定义context，传到前端统一叫object_list  
或者自定义 context_object_name = 'foo', 传到前端的就叫foo

DetailView使用时传一个<pk>进url
如果在detailview里specify了get_queryset，后续的get_object就会以该queryset为基础，在该queryset中寻找该object

对于class_based_view来说，因为是一个class，django内置的decorator就无法使用了，解决方法是各种Mixin，类似LoginRequiredMixin，这是mixin存在的基础
其实对function based view来说，把代码敲得更organized，可读性一样很高，条理清晰，譬如template_name='foo',return render(template_name)
而FBV可以以更少的学习成本更迅速的customize，突破各种应用场景
所以结论是-------------------------除非repeat like crazy，否则不上CBV


在model里定义get_absolute_url，前端调用，代码更dry


{% for ... %} 后跟 {% empty %}，意思为如果for loop里面是空的，则显示empty中内容

用as_view的时候需要封装login_required decorator，需要在url里面进行封装，不可直接使用@login_required


Local():
render(request,'...html', local())是一种简便写法，就是把所有context以各自的variable name都传到视图里，然而有时候我们不需要把中间变量也传视图，所以
使用前需谨慎考虑后续代码延展性

代码不光是自己敲，还要考虑到分工协作，所以models也好views也好，每一层都要尽量的把bug杜绝掉，哪怕是双重保险，三重保险，这种代码思路值得借鉴


AsyncIO:
单线程编程只能运用CPU算力的10%左右，要释放应用更多算力，async是解决办法


Django channel的consumer中使用了如下代码：
-------------------------------------------------------------------------------
    try:
        PrivateConsumer.members[self.group_name].add(self.socket)      
    except:                                                             
        PrivateConsumer.members[self.group_name] = set([self.socket])   
---------------------------------------------------------------------------------
这个代码有意思在，它规避了所有的报错，来试着分析一下
members是该consumer class里自定义的literable dict，字典格式。如果该键位上（members[self.group_name]）为空的话，add方法失效，所以第一次新建走
except逻辑，在该键位上新建set([self.socket])，其中self.socket是一个user object，然而set()函数只接受iliterable variable，所以要把user object
list化，加上[]封装，变成一个user object的list representation
后续的add里面，会自动把object转化成list representation，所有不必操心这一点。当该group_name键位上不为空时，add方法生效，检验该键位是否有同样的value
如果有，则什么都不做，如果没有，则在该键位上加上新value
总体来说，这是一个很高效简洁的设计





