filter返还的是一个queryset，因为可能有好几个符合条件的对象，如果要精确定位某一个对象，用get_object_or_404

pandas本是一个处理大数据的插件，有各种matrices方法可以调用，但素！因为django自带的Json解码在应对中文编码时简直是一坨屎，所以本座还是捏着鼻子用了pandas，
至于xlrd还不错，可以直接用.原始录入的院校，省市信息，本座都存到了“冲天流程”这个文件夹中



关于Serializer：

JsonResponse与HttpResponse不一样，默认是传递dictionary，但也可以传递别的data type，譬如list，return JsonResponse(data, safe=false)即可
serializer中，使用genericAPIviews通过URL参数自定义queryset时，竟然一定还非要带上modelviewset，是乃一奇案也，现下忙着上线无暇深挖，日后可以慢慢破

而且如果要在function里直接call serializer的话，一次只能serialize一个object，还得自己写for loop，还他妈有中文编码等问题...所以本座干脆在前端抓取了
为什么一次只能serialize一个object呢？因为serializer就是这样设计的，基本上可以把serializer类比form，两个用途

class FooView(APIView):

    def get(self, request, *args, **kwargs):
        qs = Post.objects.all()
        serializer = PostSerializer(qs, many=true)
        return Response(serializer.data)
        *** 注意！！！
        *** serialize完是一个OrderedDict，是一个django格式，javascript不知道咋回事，所以还要
        *** json.dumps让它变成一个json格式，然后！
        *** 在前端用{{ foo_list }}的时候，javascript并不会把它当成一个string来parse（也不知道它是json格式了）
        *** 所以就会有各种乱码/&(l|g|quo)t什么的，所以要想在前端直接开用，还要加上mark_safe
        *** 所以终极态是 mark_safe(json.dumps(serializer.data))       一个简单的问题确实被复杂化了
        
    def post(self, request, *args, **kwargs):
        serializer = PostSerializer(data=request.data)
        if serializer.is_valid()
            serializer.save()
            return Response(serializer.data)
            
            
继承 HyperlinkedModelSerializer，会隐式添加一个 HyperlinkedRelatedField 字段 url，而所有的外键都会变成 HyperlinkedRelatedField 字段，所以需要
手动设置 view_name 值，解决办法是在setting里面加上'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning'




modelForm中，要specify某些fields不是requied，有两种方法
class My_Form(ModelForm):

    address = forms.CharField(required=False)

    class Meta:
        model = My_Class
        fields = ('first_name', 'last_name' , 'address')
第二种解决办法：
class My_Form(forms.ModelForm):
    class Meta:
        model = My_Class
        fields = ('first_name', 'last_name' , 'address')

    def __init__(self, *args, **kwargs):
        super(My_Form, self).__init__(*args, **kwargs)
        self.fields['address'].required = False
        
        
Signals:
通过设立signals和@receiver(foo_signal)，在该signal触发时，可以自动运行某些code



搜索框相关:

F(stocks.price)指代旧的price，用于进行一些操作，譬如stocks.price=F(stocks.price)+2

Q()是指封装某个query，以便后续进行逻辑组合，譬如 Q(..) | ~Q(..),其中~表示not
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)), question__startswith='Who')， Q（）可以传递更具体的参数，但要注意放到最前



Generic View:

是一个Django自带的一系列默认设定的view，可以customize

ListView会找寻一个default的app/modelname_list.html，除非specify template_name
get_queryset()自定义queryset
get_context_data(**kwargs)可以自定义context，传到前端统一叫object_list  
或者自定义 context_object_name = 'foo', 传到前端的就叫foo

DetailView使用时传一个<pk>进url
如果在detailview里specify了get_queryset，后续的get_object就会以该queryset为基础，在该queryset中寻找该object

对于class_based_view来说，因为是一个class，django内置的decorator就无法使用了，解决方法是各种Mixin，类似LoginRequiredMixin，这是mixin存在的基础
其实对function based view来说，把代码敲得更organized，可读性一样很高，条理清晰，譬如template_name='foo',return render(template_name)
而FBV可以以更少的学习成本更迅速的customize，突破各种应用场景
所以结论是-------------------------除非repeat like crazy，否则不上CBV


在model里定义get_absolute_url，前端调用，代码更dry


{% for ... %} 后跟 {% empty %}，意思为如果for loop里面是空的，则显示empty中内容

用as_view的时候需要封装login_required decorator，需要在url里面进行封装，不可直接使用@login_required


Local():
render(request,'...html', local())是一种简便写法，就是把所有context以各自的variable name都传到视图里，然而有时候我们不需要把中间变量也传视图，所以
使用前需谨慎考虑后续代码延展性

代码不光是自己敲，还要考虑到分工协作，所以models也好views也好，每一层都要尽量的把bug杜绝掉，哪怕是双重保险，三重保险，这种代码思路值得借鉴


AsyncIO:
单线程编程只能运用CPU算力的10%左右，要释放应用更多算力，async是解决办法


Django channel的consumer中使用了如下代码：
-------------------------------------------------------------------------------
    try:
        PrivateConsumer.members[self.group_name].add(self.socket)      
    except:                                                             
        PrivateConsumer.members[self.group_name] = set([self.socket])   
---------------------------------------------------------------------------------
这个代码有意思在，它规避了所有的报错，来试着分析一下
members是该consumer class里自定义的literable dict，字典格式。如果该键位上（members[self.group_name]）为空的话，add方法失效，所以第一次新建走
except逻辑，在该键位上新建set([self.socket])，其中self.socket是一个user object，然而set()函数只接受iliterable variable，所以要把user object
list化，加上[]封装，变成一个user object的list representation
后续的add里面，会自动把object转化成list representation，所有不必操心这一点。当该group_name键位上不为空时，add方法生效，检验该键位是否有同样的value
如果有，则什么都不做，如果没有，则在该键位上加上新value
总体来说，这是一个很高效简洁的设计





