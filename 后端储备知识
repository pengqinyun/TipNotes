filter返还的是一个queryset，因为可能有好几个符合条件的对象，如果要精确定位某一个对象，用get_object_or_404

pandas本是一个处理大数据的插件，有各种matrices方法可以调用，但素！因为django自带的Json解码在应对中文编码时简直是一坨屎，所以本座还是捏着鼻子用了pandas，
至于xlrd还不错，可以直接用.原始录入的院校，省市信息，本座都存到了“冲天流程”这个文件夹中


serializer中，使用genericAPIviews通过URL参数自定义queryset时，竟然一定还非要带上modelviewset，是乃一奇案也，现下忙着上线无暇深挖，日后可以慢慢破


modelForm中，要specify某些fields不是requied，有两种方法
class My_Form(ModelForm):

    address = forms.CharField(required=False)

    class Meta:
        model = My_Class
        fields = ('first_name', 'last_name' , 'address')
第二种解决办法：
class My_Form(forms.ModelForm):
    class Meta:
        model = My_Class
        fields = ('first_name', 'last_name' , 'address')

    def __init__(self, *args, **kwargs):
        super(My_Form, self).__init__(*args, **kwargs)
        self.fields['address'].required = False



搜索框相关:

F(stocks.price)指代旧的price，用于进行一些操作，譬如stocks.price=F(stocks.price)+2

Q()是指封装某个query，以便后续进行逻辑组合，譬如 Q(..) | ~Q(..),其中~表示not
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)), question__startswith='Who')， Q（）可以传递更具体的参数，但要注意放到最前



Generic View:

是一个Django自带的一系列默认设定的view，可以customize

ListView会找寻一个default的app/modelname_list.html，除非specify template_name
get_queryset()自定义queryset
get_context_data(**kwargs)可以自定义context，传到前端统一叫object_list  
或者自定义 context_object_name = 'foo', 传到前端的就叫foo
DetailView使用时传一个<pk>进url

对于class_based_view来说，因为是一个class，django内置的decorator就无法使用了，解决方法是各种Mixin，类似LoginRequiredMixin，这是mixin存在的基础



{% for ... %} 后跟 {% empty %}，意思为如果for loop里面是空的，则显示empty中内容

用as_view的时候需要封装login_required decorator，需要在url里面进行封装，不可直接使用@login_required


Local():
render(request,'...html', local())是一种简便写法，就是把所有context以各自的variable name都传到视图里，然而有时候我们不需要把中间变量也传视图，所以
使用前需谨慎考虑后续代码延展性





