pandas本是一个处理大数据的插件，有各种matrices方法可以调用，但素！因为django自带的Json解码在应对中文编码时简直是一坨屎，所以本座还是捏着鼻子用了pandas，
至于xlrd还不错，可以直接用.原始录入的院校，省市信息，本座都存到了“冲天流程”这个文件夹中


serializer中，使用genericAPIviews通过URL参数自定义queryset时，竟然一定还非要带上modelviewset，是乃一奇案也，现下忙着上线无暇深挖，日后可以慢慢破


modelForm中，要specify某些fields不是requied，有两种方法
class My_Form(ModelForm):

    address = forms.CharField(required=False)

    class Meta:
        model = My_Class
        fields = ('first_name', 'last_name' , 'address')
第二种解决办法：
class My_Form(forms.ModelForm):
    class Meta:
        model = My_Class
        fields = ('first_name', 'last_name' , 'address')

    def __init__(self, *args, **kwargs):
        super(My_Form, self).__init__(*args, **kwargs)
        self.fields['address'].required = False



搜索框相关:

F(stocks.price)指代旧的price，用于进行一些操作，譬如stocks.price=F(stocks.price)+2

Q()是指封装某个query，以便后续进行逻辑组合，譬如 Q(..) | ~Q(..),其中~表示not
Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)), question__startswith='Who')， Q（）可以传递更具体的参数，但要注意放到最前



Generic View:

是一个Django自带的一系列默认设定的view，可以customize

listView会找寻一个default的app/modelname_list.html，除非specify template_name
get_queryset()自定义queryset
get_context_data(**kwargs)可以自定义context，传到前端统一叫object_list

{% for ... %} 后跟 {% empty %}，意思为如果for loop里面是空的，则显示empty中内容

用as_view的时候需要封装login_required decorator，需要在url里面进行封装，不可直接使用@login_required


Local():
render(request,'...html', local())是一种简便写法，就是把所有context以各自的variable name都传到视图里，然而有时候我们不需要把中间变量也传视图，所以
使用前需谨慎考虑后续代码延展性


关于timezone:
本座直接使用了django的timezone，即“按照用户所在时区返还用户当下的日期和时间”，这对于处理世界市场来说是django已经造好的轮子，不需要再担心白农们调夏令
时冬令时，但同时可能带来的安全问题，后期要注意


关于slug：
思考再三，还是需要slug，用以显示个人页面（或者说用以以某一个账号访问别的账号的个人页面），但考虑到username可能是中文，所以下了uuslug插件，之后再进行
请求时，务必记得先slugify(username)
